#+OPTIONS: ^:nil

* Tasks
** DONE Create utility for printing my invoices based on note.txt
   This should open note.txt, parse it, and print out an invoice
** DONE Normalize jobs on parsing
   Mcelhose --> mcel, McElhose --> mcel
** TODO Add total to printed invoice for my own expectations of $$
*** DONE Add grand total hours
*** TODO Add wage to config to compute gross pay
*** DONE Add different pay periods per Company
    Finney Farm's invoice was named with the 2-week convention that
    works for Ken's invoicing.  Maybe call this 'invoicingperiod'.
    "every 2 weeks starting on Monday"...  is waaay awesome, but also
    waaayyy beyond me and this program at this point.  Simply defining
    the period per company is fine for now.
** DONE Save invoiced entries to separate file
   Write invoice and invoiced entries to an invoice file
** TODO Add next_paydate() function to invoice
   Returns dt for next payday, has to know some previous payday to
   calculate every second week, or maybe just `if now::week_num % 2`
   because we started invoicing at the end of week 1 in the new year.
** DONE Make config have nothing to do with IO
   Right now it's written around ConfigParser which is disk-specific
   IO. I think it can be rewritten around a dictionary; and so the
   caller picks their data layer and passes it off as a dictionary.
   For now, tests and generating invoices for Ken and FF, the data
   layer will be disk.
** DONE Make invoice for Ken, on 02/12/19
   Invoice will be for last week (few hours) and this week (zero
   hours), pay period is 2/4 - 2/17
** DONE gen_invoice_task should create a pay-period specific file
** TODO The use of invoice.send() doesen't really matter
   A few tests called send(), but commenting those calls out didn't
   affect the outcome of the test.  I was thinking each entry could
   just record some maybe interesting information about its parent
   invoice, while really trying to defer on making an entry point back
   to its invoice, something like Entry --> Invoice.  Right now its
   only Invoice --> [Entry, Entry, ...].  I was also thinking that an
   invoice's ID could be computed from the interesting information,
   but why not just use a real parent-child relation with formal ids?
   And this all seems premature anyways.  Maybe I don't care enough
   about send() to justify its existence, yet.

   I found a use for it, it sets the invoiced_datetime property on the
   invoice, which is used by print_txt().

   But I'm still not sure how I even "send" an invoice, beyond the
   mechanical steps of:
   1. sync phone
   2. copy hour entries from Notes app into notes.txt
   3. run gen_invoice_task, I can specify a variabe in the file to
      select which company to invoice for
   4. copy-paste line-items from invoice txt file to another Notes app
      note
   5. sync phone
   6. text Ken
** DONE Fix self-referential asserts in testWriteInvoice()
   There are self-referential asserts in =testWriteInvoice()= that
   don't really prove anything.  This became apparent when changing
   =self.net_30= to =None= in all the =Invoice()= instantiators.
   There's a lot of date-time precision that's kept in the written
   file that might be making testing harder.

   Removed a lot of junk in =testWriteInvoice()= that had nothing to
   do with the test, which is just verifying that a file was written.
   All the exact-value assertions (especially dates and computed
   values) belong in other methods: =testSendInvoice()= and
   =testPrintInvoicedEntries()=.
** TODO Re-evaluate tests for payment_date in Invoice
   Just changed all net_30 date-times to None, and no tests broke.
   Make tests break, then fix the code.
